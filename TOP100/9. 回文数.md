### 题目描述

> 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
>
> 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。
>
>  
>
> 示例 1：
>
> 输入：x = 121
> 输出：true
> 示例 2：
>
> 输入：x = -121
> 输出：false
> 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
> 示例 3：
>
> 输入：x = 10
> 输出：false
> 解释：从右向左读, 为 01 。因此它不是一个回文数。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/palindrome-number

### 思路

此题为简单类型, 结合前面的5,7,8题, 知道了回文判断, 整数反转, 字符串整数转换, 以及整数溢出判断知识点.

应该能很快给出答案.

```c++
 bool isPalindrome(int x) {
        if(x < 0) return false;

        int res = 0, tmp = x;
        while(x != 0) {
            int n = x % 10;
            if(res > INT_MAX/10 || (res == INT_MAX/10 && n > INT_MAX%10))
                return false;
            res = res*10 + n;
            x /= 10;
        }

        return res == tmp;
    }
```

### 优化

看了题解, 除了转字符串, 以及上述方法外, 还有一种更优解法:

反转一半数字并比较, 关键点:

- 如何判断是否反转了一半? : 当原始数字小于或者等于反转数字时即可

- 如何处理数字长度为奇数或偶数情况?

  只需在判断相等时多加一条判断为奇数的情况即可:

  - 偶数: x == res
  - 奇数: x == res/10, 如: 12321, 当 x=12, res=123时退出, 此时只需将res/10 去掉中间数字即可

在第一种解法的基础上, 进行简单修改, 代码如下:

注意: 

- 直接修改, 第一次提交踩了坑:

  由于取消了反转整个数字, 漏掉了一个例外: 当数字尾数为0的情况, 

  比如输入: 10,  循环退出时: x=0, res=1,  此时 res/10 == x,  会判断为true.

  **故反转一半数字的前提是: 除0之外, 数字尾部不能有0**,

  因为有0的存在, 取一半这个算法就会出错, 会多往前取数字,  这就造成两边不相等了, 与回文的定义相悖.

```c++
bool isPalindrome(int x) {
    if(x < 0 || (x%10 == 0 && x != 0)) return false;

    int res = 0;
    while(x > res) {
        res = res*10 + x % 10;
        x /= 10;
    }

    return res == x || res/10 == x;
}
```

